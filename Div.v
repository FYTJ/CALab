// Generated by CIRCT firtool-1.62.1-1-gdf5ed6ea5
module Div(
  input         clock,
                reset,
  output        io_in_ready,
  input         io_in_valid,
  input  [3:0]  io_in_bits_divOp,
  input  [31:0] io_in_bits_dividend,
                io_in_bits_divisor,
  input         io_out_ready,
  output        io_out_valid,
  output [31:0] io_out_bits_quotient,
                io_out_bits_remainder
);

  reg  [31:0] dividend;
  reg  [31:0] divisor;
  reg  [3:0]  divOp;
  reg  [5:0]  clk_counter;
  reg         status;
  wire        _io_out_bits_remainder_T = divOp == 4'h1;
  wire        _io_out_bits_remainder_T_1 = divOp == 4'h4;
  wire        sign_dividend =
    (_io_out_bits_remainder_T | _io_out_bits_remainder_T_1) & dividend[31];
  wire        sign_quotient =
    sign_dividend ^ (_io_out_bits_remainder_T | _io_out_bits_remainder_T_1) & divisor[31];
  reg  [31:0] num_quotient;
  reg  [31:0] num_remainder;
  reg  [30:0] add_dividend;
  reg  [32:0] new_dividend;
  wire        io_out_valid_0 = clk_counter == 6'h20 & status;
  wire [31:0] _zext_in_dividend_T_6 =
    (io_in_bits_divOp == 4'h1 | io_in_bits_divOp == 4'h4) & io_in_bits_dividend[31]
      ? 32'h0 - io_in_bits_dividend
      : io_in_bits_dividend;
  wire        _GEN = ~status & io_in_valid;
  wire        _GEN_0 = ~(clk_counter[5]) & status;
  wire        _GEN_1 = divisor == 32'h0;
  wire [32:0] _sub_T =
    new_dividend
    - {1'h0,
       (_io_out_bits_remainder_T | _io_out_bits_remainder_T_1) & divisor[31]
         ? 32'h0 - divisor
         : divisor};
  wire [31:0] remainder = _sub_T[32] ? new_dividend[31:0] : _sub_T[31:0];
  wire        _GEN_2 = clk_counter == 6'h20 & io_out_ready & io_out_valid_0;
  always @(posedge clock) begin
    if (reset) begin
      dividend <= 32'h0;
      divisor <= 32'h0;
      divOp <= 4'h1;
      clk_counter <= 6'h0;
      status <= 1'h0;
      num_quotient <= 32'h0;
      num_remainder <= 32'h0;
      add_dividend <= 31'h0;
      new_dividend <= 33'h0;
    end
    else begin
      if (_GEN) begin
        dividend <= io_in_bits_dividend;
        divisor <= io_in_bits_divisor;
        divOp <= io_in_bits_divOp;
        clk_counter <= 6'h0;
        add_dividend <= _zext_in_dividend_T_6[30:0];
        new_dividend <= {32'h0, _zext_in_dividend_T_6[31]};
      end
      else begin
        if (_GEN_0) begin
          if (_GEN_1) begin
            clk_counter <= 6'h20;
            num_quotient <= sign_quotient ? 32'h1 : 32'hFFFFFFFF;
          end
          else begin
            clk_counter <= clk_counter + 6'h1;
            num_quotient <= {num_quotient[30:0], ~(_sub_T[32])};
          end
        end
        else if (_GEN_2) begin
          clk_counter <= 6'h0;
          num_quotient <= 32'h0;
        end
        if (~_GEN_0 | _GEN_1) begin
        end
        else begin
          add_dividend <= {add_dividend[29:0], 1'h0};
          if (clk_counter == 6'h1F)
            new_dividend <= 33'h0;
          else
            new_dividend <= {remainder, add_dividend[30]};
        end
      end
      status <= _GEN | (_GEN_0 | ~_GEN_2) & status;
      if (_GEN | ~_GEN_0) begin
      end
      else
        num_remainder <=
          _GEN_1
            ? ((_io_out_bits_remainder_T | _io_out_bits_remainder_T_1) & sign_dividend
                 ? ~dividend + 32'h1
                 : dividend)
            : remainder;
    end
  end // always @(posedge)
  assign io_in_ready = ~status;
  assign io_out_valid = io_out_valid_0;
  assign io_out_bits_quotient =
    (_io_out_bits_remainder_T | _io_out_bits_remainder_T_1) & sign_quotient
      ? ~num_quotient + 32'h1
      : num_quotient;
  assign io_out_bits_remainder =
    (_io_out_bits_remainder_T | _io_out_bits_remainder_T_1) & sign_dividend
      ? ~num_remainder + 32'h1
      : num_remainder;
endmodule

